#####################################################################
#
# CSCB58 Winter 2025 Assembly Final Project
# University of Toronto, Scarborough
#
# Student: Nevin Ada Cakmak, 100985646, utorid: cakmak, nevinada.cakmak@mail.utoronto.ca
# # Bitmap Display Configuration:
# - Unit width in pixels: 4
# - Unit height in pixels: 4
# - Display width in pixels: 512
# - Display height in pixels: 256
# - Base Address for Display: 0x10008000 ($gp)
#
# Which milestoneshave been reached in this submission?
# - Milestone 1/2/3/4
#
# Which approved features have been implemented for milestone 4?
# 1. Multiple Levels, I have 6 levels
# 2. Starting Menu, Select the option with W/S, and press 7
# 3. Objects Move, the pickup objects move to the left and right
#
# # Link to video demonstration for final submission: 
# - https://youtu.be/a4eeBAqVh_A
# # Are you OK with us sharing the video with people outside course staff? 
# - yes, the repo will be public after the final exam: https://github.com/nevinadacakmak/b58-assemblygame 
#
# # Any additional information that the TA needs to know:
# - 'r' only restarts the game if the game did not end yet
# - 'p' pauses the game.
# - to skip drawing levels, use the cheat code '9'
# - in drawing levels, make sure to go left up before painting to paint, otherwise the cursor is at the borders
# - i debugged this in VS code, so indent levels vary, i hope this is not a problem. 
#
#####################################################################

.eqv BASE_ADDRESS 0x10008000
.eqv KEYBOARD_ADDRESS 0xffff0000
.eqv KEYBOARD_DATA 0xffff0004

.data
char_x: .word 50   # Initial x position
char_y: .word 30   # Initial y position

is_on_platform: .word 0    # 1 if standing on platform, 0 if not
game_over: .word 0         # 1 if game is over, 0 if still playing
level_complete: .word 0    # 1 if level is complete, 0 if still playing
current_level: .word 1     # Current level (1-6)
max_level: .word 6         # Maximum level

score: .word 0
time_remaining: .word 40    # Time remaining in seconds
last_time_update: .word 0
game_paused: .word 0        # 1 if game is paused, 0 if playing

move_step: .word 4         # How many pixels to move per keystroke
gravity_step: .word 2      # How many pixels to fall per frame

# Level 1 parameters
platform1_x: .word 50      
platform1_y: .word 40      
platform1_width: .word 48
platform1_height: .word 3  

platform2_x: .word 10      
platform2_y: .word 50      
platform2_width: .word 48  
platform2_height: .word 3  

# Level 3 parameters
platform3_x: .word 65    
platform3_y: .word 35      
platform3_width: .word 32  
platform3_height: .word 2  

platform4_x: .word 35      
platform4_y: .word 40      
platform4_width: .word 32  
platform4_height: .word 2  

platform5_x: .word 95     
platform5_y: .word 30      
platform5_width: .word 28  
platform5_height: .word 2  

# Level 5 parameters
platform6_x: .word 50      
platform6_y: .word 30      
platform6_width: .word 24  
platform6_height: .word 1  

platform7_x: .word 25      
platform7_y: .word 35      
platform7_width: .word 24  
platform7_height: .word 1  

platform8_x: .word 75     
platform8_y: .word 42      
platform8_width: .word 24  
platform8_height: .word 1  

platform9_x: .word 5 
platform9_y: .word 42 
platform9_width: .word 24  
platform9_height: .word 1  

character_width: .word 3   # Width of character
character_height: .word 8  # Height of character
screen_height: .word 64

# Level 1 pickups
pickup1_visible: .word 1  # 1 if pickup is visible, 0 if collected
pickup1_x: .word 88      
pickup1_y: .word 30      

pickup2_visible: .word 1  
pickup2_x: .word 20      
pickup2_y: .word 42      

pickup3_visible: .word 1  
pickup3_x: .word 60      
pickup3_y: .word 30      

# Level 3 pickups
pickup4_visible: .word 1  
pickup4_x: .word 116     
pickup4_y: .word 22

pickup5_visible: .word 1  
pickup5_x: .word 65    
pickup5_y: .word 27

pickup6_visible: .word 1  
pickup6_x: .word 50    
pickup6_y: .word 32

# Level 5 pickups
pickup7_visible: .word 1  
pickup7_x: .word 35     
pickup7_y: .word 25      

pickup8_visible: .word 1  
pickup8_x: .word 90      
pickup8_y: .word 33      

pickup9_visible: .word 1 
pickup9_x: .word 10      
pickup9_y: .word 34      

pickup_width: .word 3   # Width of pickup
pickup_height: .word 7  # Height of pickup

digits_array: .word 0:10

# Drawing game variables
cursor_x: .word 4
cursor_y: .word 4 
current_color: .word 0  # selected color index
drawing_complete: .word 0

target_drawing: .word 0:25 
player_drawing: .word 0:25

# Drawing accuracy score
drawing_accuracy: .word 0   # How accurate is player's drawing (0-100%)

colors: .word 0x1dbaee, 0x625e63, 0x837e87, 0x4b692f, 0xf7a90f, 0x211f34, 0xedc39a, 0xdeb790, 0xd59555, 0xff0000, 0x0017ff, 0x00791a
colorCount: .word 12

paintingcolors: .word 0xf7a90f, 0x0017ff, 0x00791a, 0xff0000
paintingcolorCount: .word 4

menu_cursor_pos: .word 0    # 0 = Start, 1 = Exit
menu_color_1: .word 0xFFFFFF  # White
menu_color_2: .word 0xFF0000  # Red

pickup_offset: .word 0    # 0 or 1 will be toggled each second, to make pickups move

.text
	li $t0, BASE_ADDRESS

# Draw start menu and handle input
draw_start_menu:
	la $s6, colors  # Set up color palette
    	# Save return address
    	addi $sp, $sp, -4
    	sw $ra, 0($sp)
    
    	li $t0, BASE_ADDRESS
    	lw $t2, 8($s6)  # Background color
    	li $t5, 0       # Pixel counter
    
clear_screen:
    sw $t2, 0($t0)
    addi $t0, $t0, 4
    addi $t5, $t5, 1
    li $t6, 8192
    blt $t5, $t6, clear_screen
    
    li $t0, BASE_ADDRESS
    addi $t0, $t0, 14336  # y = 28
    addi $t0, $t0, 180    # x = 60
    
    # Choose color based on cursor position
    lw $t3, menu_cursor_pos
    beq $t3, $zero, highlight_start
    lw $t1, 20($s6)   # Normal color
    j draw_start
highlight_start:
    lw $t1, 36($s6)   # Highlight color


draw_start:
    # Draw "START"
    # S
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    sw $t1, 12($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 0($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 12($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    sw $t1, 12($t0)
    
    # Move to T position
    subi $t0, $t0, 2048     # Go back up
    addi $t0, $t0, 20       # Move right
    
    # T
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 4($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 4($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 4($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 4($t0)
    
    # Move to A position
    subi $t0, $t0, 2048     # Go back up
    addi $t0, $t0, 16       # Move right
    
    # A
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 0($t0)
    sw $t1, 12($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    sw $t1, 12($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 0($t0)
    sw $t1, 12($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 0($t0)
    sw $t1, 12($t0)
    
       # Move to R position
    subi $t0, $t0, 2048     # Go back up
    addi $t0, $t0, 20       # Move right
    
    # R
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 0($t0)
    sw $t1, 12($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 0($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 0($t0)
    sw $t1, 12($t0)
    
    # Move to T position
    subi $t0, $t0, 2048     # Go back up
    addi $t0, $t0, 20       # Move right
    
    # T
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    sw $t1, 12($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    
    # Draw "EXIT" text below
    addi $t0, $t0, 4096
    
    # Choose color based on cursor position
    lw $t3, menu_cursor_pos
    beq $t3, 1, highlight_exit
    lw $t1, 20($s6)   # Normal color
    j draw_exit
highlight_exit:
    lw $t1, 36($s6)   # Highlight color

draw_exit:
    # Position for EXIT
    li $t0, BASE_ADDRESS
    addi $t0, $t0, 17408
    addi $t0, $t0, 180
    
    # E
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    sw $t1, 12($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 0($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 0($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    sw $t1, 12($t0)
    
    # Move to X position
    subi $t0, $t0, 2048     # Go back up
    addi $t0, $t0, 20       # Move right
    
    # X
    sw $t1, 0($t0)
    sw $t1, 12($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 0($t0)
    sw $t1, 12($t0)
    
    # Move to X position
    subi $t0, $t0, 2048     # Go back up
    addi $t0, $t0, 20       # Move right
    
    # I
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 4($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 4($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 4($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    
    # Move to T position
    subi $t0, $t0, 2048     # Go back up
    addi $t0, $t0, 20       # Move right
    
    # T
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    sw $t1, 12($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512      # Next row
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    
menu_input:
    # Check for keyboard input
    li $t0, KEYBOARD_ADDRESS
    lw $t0, 0($t0)
    andi $t0, $t0, 1
    beqz $t0, menu_input
    
    # Get key value
    li $t9, KEYBOARD_DATA
    lw $t9, 0($t9)
    
    # Process input
    beq $t9, 0x77, menu_up      # 'w' key
    beq $t9, 0x73, menu_down    # 's' key
    beq $t9, 0x37, menu_select  # 7 key
    j menu_input
    
menu_up:
    li $t0, 0
    sw $t0, menu_cursor_pos
    j draw_start_menu
    
menu_down:
    li $t0, 1
    sw $t0, menu_cursor_pos
    j draw_start_menu
    
menu_select:
    # Check which option was selected
    lw $t0, menu_cursor_pos
    beq $t0, 1, menu_exit
    
    #almost like main:
    
    jal set_level_1
    jal paint
    
    # Initialize time tracking
    li $v0, 30 
    syscall
    sw $a0, last_time_update
    
    j game_loop 
    
menu_exit:
    li $v0, 10
    syscall

.globl main	
main:
	la $s6, colors
        jal draw_start_menu
	jal set_level_1 
	jal paint 
	
	# Initialize time tracking
	li $v0, 30 
	syscall
	sw $a0, last_time_update
    
game_loop:
    lw $t0, game_over
    bne $t0, $zero, check_keyboard  # If game over, only check for keyboard input
    
    # Check if level is complete
    lw $t0, level_complete
    bne $t0, $zero, advance_level_wrapper
    
    lw $t0, game_paused
    bne $t0, $zero, check_keyboard  # If paused, only check for keyboard input

    lw $t0, current_level
    li $t1, 2
    beq $t0, $t1, skip_physics
    li $t1, 4
    beq $t0, $t1, skip_physics
    li $t1, 6
    beq $t0, $t1, skip_physics
    
    # Update time remaining
    jal update_time
    
    jal apply_gravity
    jal check_all_collisions
    j after_physics

    skip_physics:
        jal update_time
        
    after_physics:
        # Check for keyboard input
        jal check_keyboard
        
        li $a0, 30
        li $v0, 32  # Sleep syscall
        syscall
        
        j game_loop

    advance_level_wrapper:
        jal advance_level
        jal paint  # Redraw with new level
        j game_loop
	
# Update time remaining based on system clock
update_time:
	addi $sp, $sp, -4
	sw $ra, 0($sp)
	
	li $v0, 30 
	syscall
	
	lw $t0, last_time_update
	sub $t1, $a0, $t0
	
	# Check if a second has passed
	li $t2, 1000
	blt $t1, $t2, update_time_done
	
	sw $a0, last_time_update
	lw $t3, time_remaining
	beq $t3, $zero, time_up #end game

    # Toggle pickup positions
    lw $t4, pickup_offset
    xori $t4, $t4, 1        # Toggle between 0 and 1
    sw $t4, pickup_offset
    
    lw $t5, current_level
    
    li $t6, 1
    beq $t5, $t6, update_level1_pickups
    
    li $t6, 3
    beq $t5, $t6, update_level3_pickups
    
    li $t6, 5
    beq $t5, $t6, update_level5_pickups
    
    j finish_update_time

# FUnction to animate the pickups, one left, one right, and 0
update_level1_pickups:
    # Move pickup1
    lw $t7, pickup1_x
    beq $t4, $zero, restore1
    addi $t7, $t7, -1      # Move left
    j save1
restore1:
    addi $t7, $t7, 1       # Move right
save1:
    sw $t7, pickup1_x
    
    # Repeat for pickup2 and 3
    lw $t7, pickup2_x
    beq $t4, $zero, restore2
    addi $t7, $t7, -1
    j save2
restore2:
    addi $t7, $t7, 1
save2:
    sw $t7, pickup2_x
    
    lw $t7, pickup3_x
    beq $t4, $zero, restore3
    addi $t7, $t7, -1
    j save3
restore3:
    addi $t7, $t7, 1
save3:
    sw $t7, pickup3_x
    j finish_update_time

update_level3_pickups:
    # Move pickup4
    lw $t7, pickup4_x
    beq $t4, $zero, restore4
    addi $t7, $t7, -1      # Move left
    j save4
restore4:
    addi $t7, $t7, 1       # Move right
save4:
    sw $t7, pickup4_x
    
    lw $t7, pickup5_x
    beq $t4, $zero, restore5
    addi $t7, $t7, -1
    j save5
restore5:
    addi $t7, $t7, 1
save5:
    sw $t7, pickup5_x
    
    lw $t7, pickup6_x
    beq $t4, $zero, restore6
    addi $t7, $t7, -1
    j save6
restore6:
    addi $t7, $t7, 1
save6:
    sw $t7, pickup6_x
    j finish_update_time

update_level5_pickups:
    # Move pickup7
    lw $t7, pickup7_x
    beq $t4, $zero, restore7
    addi $t7, $t7, -1      # Move left
    j save7
restore7:
    addi $t7, $t7, 1       # Move right
save7:
    sw $t7, pickup7_x
    
    lw $t7, pickup8_x
    beq $t4, $zero, restore8
    addi $t7, $t7, -1
    j save8
restore8:
    addi $t7, $t7, 1
save8:
    sw $t7, pickup8_x
    
    lw $t7, pickup9_x
    beq $t4, $zero, restore9
    addi $t7, $t7, -1
    j save9
restore9:
    addi $t7, $t7, 1
save9:
    sw $t7, pickup9_x
    j finish_update_time

finish_update_time:
    addi $t3, $t3, -1
    sw $t3, time_remaining
    jal paint

update_time_done:
	lw $ra, 0($sp)
	addi $sp, $sp, 4
	jr $ra

time_up:
	li $t0, 1
	sw $t0, game_over
	jal draw_game_over

# Function to check all collision types
check_all_collisions:
	addi $sp, $sp, -4
	sw $ra, 0($sp)
	
	jal check_platform_collision
	jal check_all_pickups
	
	# Check if all pickups are collected
	jal check_level_complete
	
	lw $ra, 0($sp)
	addi $sp, $sp, 4
	jr $ra

check_level_complete:
    addi $sp, $sp, -4
    sw $ra, 0($sp)
    
    lw $t0, current_level
    
    # If it's a drawing level, check if drawing is complete
    li $t1, 2
    beq $t0, $t1, check_drawing_complete
    li $t1, 4
    beq $t0, $t1, check_drawing_complete
    li $t1, 6
    beq $t0, $t1, check_drawing_complete
    
    # Check which level we're on
    li $t1, 1
    beq $t0, $t1, check_level1_pickups
    
    li $t1, 3
    beq $t0, $t1, check_level3_pickups

    li $t1, 5
    beq $t0, $t1, check_level5_pickups
    
    j level_check_done
    
check_level1_pickups:
    # Check if all 3 pickups in level 1 are collected
    lw $t1, pickup1_visible
    lw $t2, pickup2_visible
    lw $t3, pickup3_visible
    
    # Combine results - if any are still visible (1), then not all collected
    or $t4, $t1, $t2
    or $t4, $t4, $t3
    
    beq $t4, $zero, mark_level_complete
    j level_check_done
    
check_level3_pickups:
    # Check if all 3 pickups in level 3 are collected
    lw $t1, pickup4_visible
    lw $t2, pickup5_visible
    lw $t3, pickup6_visible
    
    # Combine results - if any are still visible (1), then not all collected
    or $t4, $t1, $t2
    or $t4, $t4, $t3
    
    beq $t4, $zero, mark_level_complete
    j level_check_done
    
check_level5_pickups:
    # Check if all 3 pickups in level 5 are collected
    lw $t1, pickup7_visible
    lw $t2, pickup8_visible
    lw $t3, pickup9_visible
    
    # Combine results, if any are still visible (1), then not all collected
    or $t4, $t1, $t2
    or $t4, $t4, $t3
    
    beq $t4, $zero, mark_level_complete
    j level_check_done
    
check_drawing_complete:
    lw $t0, drawing_complete
    beq $t0, $zero, level_check_done
    
    lw $t0, drawing_accuracy
    li $t1, 30
    blt $t0, $t1, fail_drawing_level  # FAIL if accuracy < 30%
    
    li $t0, 1
    sw $t0, level_complete
    
    j level_check_done

fail_drawing_level:
    # Set game over state
    li $t0, 1
    sw $t0, game_over
    
    jal paint
    j level_check_done
    
mark_level_complete:
    li $t0, 1
    sw $t0, level_complete
    
level_check_done:
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra

# I KNOW THIS IS VERY BAD QUALITY CODE (CHECK FOR PICKUP & COLLISIONS) BUT I DID NOT HAVE TIME TO FIX IT

# Function to check collisions with all pickups for the current level
check_all_pickups:
    addi $sp, $sp, -4
    sw $ra, 0($sp)
    
    lw $t0, current_level
    
    # Check which level we're on
    li $t1, 1
    beq $t0, $t1, check_level1_pickup_collisions
    
    li $t1, 3
    beq $t0, $t1, check_level3_pickup_collisions

    li $t1, 5
    beq $t0, $t1, check_level5_pickup_collisions
    
    j check_pickups_done
    
check_level1_pickup_collisions:
	# Check collisions with all 3 pickups in level 1
	la $a0, pickup1_visible
	lw $a1, pickup1_x
	lw $a2, pickup1_y
	jal check_collision_pickup
	
	la $a0, pickup2_visible
	lw $a1, pickup2_x
	lw $a2, pickup2_y
	jal check_collision_pickup
	
	la $a0, pickup3_visible
	lw $a1, pickup3_x
	lw $a2, pickup3_y
	jal check_collision_pickup
	
	j check_pickups_done
	
check_level3_pickup_collisions:
	# Check collisions with all 3 pickups in level 3
	la $a0, pickup4_visible
	lw $a1, pickup4_x
	lw $a2, pickup4_y
	jal check_collision_pickup
	
	la $a0, pickup5_visible
	lw $a1, pickup5_x
	lw $a2, pickup5_y
	jal check_collision_pickup
	
	la $a0, pickup6_visible
	lw $a1, pickup6_x
	lw $a2, pickup6_y
	jal check_collision_pickup
	
	j check_pickups_done
	
check_level5_pickup_collisions:
	# Check collisions with all 3 pickups in level 5
	la $a0, pickup7_visible
	lw $a1, pickup7_x
	lw $a2, pickup7_y
	jal check_collision_pickup
	
	la $a0, pickup8_visible
	lw $a1, pickup8_x
	lw $a2, pickup8_y
	jal check_collision_pickup
	
	la $a0, pickup9_visible
	lw $a1, pickup9_x
	lw $a2, pickup9_y
	jal check_collision_pickup
	
check_pickups_done:
	lw $ra, 0($sp)
	addi $sp, $sp, 4
	jr $ra

# Function to advance to the next level
advance_level:
	addi $sp, $sp, -4
	sw $ra, 0($sp)
	
	li $t0, 0
	sw $t0, level_complete
	
	# Increment level
	lw $t0, current_level
	addi $t0, $t0, 1
	lw $t1, max_level
	
	bgt $t0, $t1, game_completed
	
	sw $t0, current_level
	
	li $t1, 1
	beq $t0, $t1, set_level_1
	
	li $t1, 2
	beq $t0, $t1, set_level_2
	
	li $t1, 3
	beq $t0, $t1, set_level_3
	
	li $t1, 4
	beq $t0, $t1, set_level_4
	
	li $t1, 5
	beq $t0, $t1, set_level_5
	
	li $t1, 6
	beq $t0, $t1, set_level_6


    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra

game_completed:
    # Draw "WOW!" text at center screen
    li $t0, BASE_ADDRESS
    
    # Calculate position
    li $t6, 128
    mul $t6, $t6, 42
    add $t6, $t6, 40 #x y coordinates
    mul $t6, $t6, 4
    add $t0, $t0, $t6
    
    lw $t1, 44($s6)
    
    # Draw "WOW!"
    # W
    sw $t1, 0($t0)
    sw $t1, 16($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 16($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 8($t0)
    sw $t1, 16($t0)
    addi $t0, $t0, 512
    sw $t1, 4($t0)
    sw $t1, 12($t0)
    
    # Move to O position
    subi $t0, $t0, 1536
    addi $t0, $t0, 24
    
    # O
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 12($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 12($t0)
    addi $t0, $t0, 512
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    
    # Move to W position
    subi $t0, $t0, 1536
    addi $t0, $t0, 20
    
    # W
    sw $t1, 0($t0)
    sw $t1, 16($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 16($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 8($t0)
    sw $t1, 16($t0)
    addi $t0, $t0, 512
    sw $t1, 4($t0)
    sw $t1, 12($t0)
    
    # Move to ! position
    subi $t0, $t0, 1536
    addi $t0, $t0, 24
    
    # !
    sw $t1, 0($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    addi $t0, $t0, 1024
    sw $t1, 0($t0)
    
    # Draw Score
    addi $t0, $t0, 1024
    subi $t0, $t0, 60 
    
    # Draw score number
    li $a0, 80           
    li $a1, 45 
    li $a2, 10 
    la $a3, score 
    jal draw_number
    
    j exit

# Functions to set up each level
set_level_1:
	addi $sp, $sp, -4
	sw $ra, 0($sp)
	
	li $t0, 50
	sw $t0, char_x
	li $t0, 30
	sw $t0, char_y
	
	li $t0, 1
	sw $t0, pickup1_visible
	sw $t0, pickup2_visible
	sw $t0, pickup3_visible
	
	li $t0, 40
	sw $t0, time_remaining
	
	li $t0, 0
	sw $t0, level_complete
	
	li $v0, 30
	syscall
	sw $a0, last_time_update
	
	lw $ra, 0($sp)
	addi $sp, $sp, 4
	jr $ra
    
set_level_2:
    addi $sp, $sp, -4
    sw $ra, 0($sp)
    
    li $t0, 5
    sw $t0, cursor_x
    sw $t0, cursor_y
    
    li $t0, 0
    sw $t0, current_color
    
    li $t0, 0
    sw $t0, drawing_complete
    sw $t0, drawing_accuracy
    
    jal load_target_drawing_level2
    
    la $t0, player_drawing
    li $t1, 0 
    li $t2, 25
init_player_drawing_loop2:
    sw $zero, 0($t0)
    addi $t0, $t0, 4 
    addi $t1, $t1, 1 
    blt $t1, $t2, init_player_drawing_loop2
    
    li $t0, 30
    sw $t0, time_remaining
    
    li $t0, 0
    sw $t0, level_complete
    
    li $v0, 30
    syscall
    sw $a0, last_time_update
    
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra

set_level_3:
	addi $sp, $sp, -4
	sw $ra, 0($sp)
	
	li $t0, 40
	sw $t0, char_x
	li $t0, 20
	sw $t0, char_y
	
	li $t0, 1
	sw $t0, pickup4_visible
	sw $t0, pickup5_visible
	sw $t0, pickup6_visible
	
	li $t0, 30
	sw $t0, time_remaining
	
	li $t0, 0
	sw $t0, level_complete
	
	li $v0, 30
	syscall
	sw $a0, last_time_update
	
	lw $ra, 0($sp)
	addi $sp, $sp, 4
	jr $ra

set_level_4:
    addi $sp, $sp, -4
    sw $ra, 0($sp)
    
    li $t0, 5
    sw $t0, cursor_x
    sw $t0, cursor_y
    
    li $t0, 0
    sw $t0, current_color
    
    li $t0, 0
    sw $t0, drawing_complete
    sw $t0, drawing_accuracy
    
    jal load_target_drawing_level4
    
    # Initialize player drawing to all zeros
    la $t0, player_drawing
    li $t1, 0
    li $t2, 25
init_player_drawing_loop4:
    sw $zero, 0($t0)
    addi $t0, $t0, 4
    addi $t1, $t1, 1
    blt $t1, $t2, init_player_drawing_loop4
    
    li $t0, 30
    sw $t0, time_remaining
    
    li $t0, 0
    sw $t0, level_complete
    
    # Get current time for time tracking
    li $v0, 30
    syscall
    sw $a0, last_time_update
    
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra

set_level_5:
	addi $sp, $sp, -4
	sw $ra, 0($sp)
	
	li $t0, 30
	sw $t0, char_x
	li $t0, 10
	sw $t0, char_y
	
	li $t0, 1
	sw $t0, pickup7_visible
	sw $t0, pickup8_visible
	sw $t0, pickup9_visible
	
	li $t0, 20
	sw $t0, time_remaining
	
	li $t0, 0
	sw $t0, level_complete
	
	li $v0, 30
	syscall
	sw $a0, last_time_update
	
	lw $ra, 0($sp)
	addi $sp, $sp, 4
	jr $ra

set_level_6:
    addi $sp, $sp, -4
    sw $ra, 0($sp)
    
    li $t0, 5 
    sw $t0, cursor_x
    sw $t0, cursor_y
    
    li $t0, 0
    sw $t0, current_color
    
    li $t0, 0
    sw $t0, drawing_complete
    sw $t0, drawing_accuracy
    
    jal load_target_drawing_level6
    
    la $t0, player_drawing
    li $t1, 0      # Index
    li $t2, 25     # Size
init_player_drawing_loop6:
    sw $zero, 0($t0)
    addi $t0, $t0, 4
    addi $t1, $t1, 1
    blt $t1, $t2, init_player_drawing_loop6
    
    li $t0, 30
    sw $t0, time_remaining
    
    li $t0, 0
    sw $t0, level_complete
    
    li $v0, 30
    syscall
    sw $a0, last_time_update
    
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra

check_collision_pickup:
	addi $sp, $sp, -4
	sw $ra, 0($sp)
	
	# Check if pickup is already collected
	lw $t0, 0($a0)
	beq $t0, $zero, collision_check_done_pickup
	
	lw $t0, char_x
	lw $t1, char_y
	lw $t2, character_width
	lw $t3, character_height
	add $t4, $t0, $t2  # character right edge
	add $t5, $t1, $t3  # character bottom edge
	
	move $t6, $a1 
	move $t7, $a2 
	lw $t8, pickup_width
	lw $t9, pickup_height
	add $s0, $t6, $t8  # pickup right edge
	add $s1, $t7, $t9  # pickup bottom edge
	
	# No collision if:
	# Character's right edge < pickup's left edge
	# Character's left edge > pickup's right edge
	# Character's bottom edge < pickup's top edge
	# Character's top edge > pickup's bottom edge
	blt $t4, $t6, collision_check_done_pickup
	blt $s0, $t0, collision_check_done_pickup
	blt $t5, $t7, collision_check_done_pickup
	blt $s1, $t1, collision_check_done_pickup 
	
	# If we reach here, collision detected!
	
	li $t0, 0
	sw $t0, 0($a0)
	
	# Increase score
	lw $t0, score
	addi $t0, $t0, 50
	sw $t0, score
	
	# Update the display
	jal paint
	
collision_check_done_pickup:
	lw $ra, 0($sp)
	addi $sp, $sp, 4
	jr $ra

check_keyboard:
	addi $sp, $sp, -4
	sw $ra, 0($sp)
	
	# Check if a key has been pressed
	li $t0, KEYBOARD_ADDRESS
	lw $t0, 0($t0)
	andi $t0, $t0, 1
	beq $t0, $zero, no_input
	
	# Get the key value
	li $t9, KEYBOARD_DATA
	lw $t9, 0($t9)
	
	# Check if we're in a drawing level
    	lw $t8, current_level
    	li $t7, 2
    	beq $t8, $t7, check_drawing_input
    	li $t7, 4
    	beq $t8, $t7, check_drawing_input
    	li $t7, 6
    	beq $t8, $t7, check_drawing_input
	
	# Process based on key value
	beq $t9, 0x77, move_up      # 'w' key
	beq $t9, 0x61, move_left    # 'a' key
	beq $t9, 0x73, move_down    # 's' key
	beq $t9, 0x64, move_right   # 'd' key
	beq $t9, 0x72, restart_game # 'r' key
	beq $t9, 0x71, quit_game    # 'q' key
	beq $t9, 0x70, toggle_pause # 'p' key
	j input_done

check_drawing_input:
# Process drawing game inputs
	beq $t9, 0x77, move_cursor_up     # 'w' key
	beq $t9, 0x61, move_cursor_left   # 'a' key
	beq $t9, 0x73, move_cursor_down   # 's' key
	beq $t9, 0x64, move_cursor_right  # 'd' key
	beq $t9, 0x31, select_color_1     # '1' key
	beq $t9, 0x32, select_color_2     # '2' key
	beq $t9, 0x33, select_color_3     # '3' key
	beq $t9, 0x34, select_color_4     # '4' key
	beq $t9, 0x35, paint_pixel        # 5 key (paint pixel)
	beq $t9, 0x36, submit_drawing     # 6 key (submit drawing)
	beq $t9, 0x72, restart_game       # 'r' key
	beq $t9, 0x71, quit_game          # 'q' key
	beq $t9, 0x70, toggle_pause       # 'p' key
        beq $t9, 0x39, force_level_advance  # '9' key to force advance at drawing levels, cheat code :-)
	j input_done

force_level_advance:
    #debugging
    li $t0, 1
    sw $t0, level_complete
    jal advance_level
    j input_done
    
move_cursor_up:
    lw $t0, cursor_y
    beqz $t0, input_done  # Don't move if at top
    subi $t0, $t0, 1
    sw $t0, cursor_y
    j update_cursor
    
move_cursor_down:
    lw $t0, cursor_y
    addi $t0, $t0, 1
    li $t1, 4
    bgt $t0, $t1, input_done  # Don't move if at bottom
    sw $t0, cursor_y
    j update_cursor
    
move_cursor_left:
    lw $t0, cursor_x
    beqz $t0, input_done  # Don't move if at left edge
    subi $t0, $t0, 1
    sw $t0, cursor_x
    j update_cursor
    
move_cursor_right:
    lw $t0, cursor_x
    addi $t0, $t0, 1
    li $t1, 4
    bgt $t0, $t1, input_done  # Don't move if at right edge
    sw $t0, cursor_x
    j update_cursor
    
select_color_1:
    li $t0, 0
    sw $t0, current_color
    j update_cursor
    
select_color_2:
    li $t0, 1
    sw $t0, current_color
    j update_cursor
    
select_color_3:
    li $t0, 2
    sw $t0, current_color
    j update_cursor
    
select_color_4:
    li $t0, 3
    sw $t0, current_color
    j update_cursor
    
paint_pixel:
    lw $t0, cursor_y
    lw $t1, cursor_x
    
    mul $t2, $t0, 5
    add $t2, $t2, $t1
    sll $t2, $t2, 2
    
    # Store color
    la $t3, player_drawing
    add $t3, $t3, $t2
    lw $t4, current_color
    addi $t4, $t4, 1  # Store 1-4 instead of 0-3
    sw $t4, 0($t3)
    
    j update_cursor
    
submit_drawing:
    jal calculate_drawing_accuracy
    
    li $t0, 1
    sw $t0, drawing_complete

    lw $t0, drawing_accuracy
    li $t1, 30
    blt $t0, $t1, submit_failed  # Less than 30% = fail
    
    li $t0, 1
    sw $t0, level_complete

    # Check if this was the final level
    lw $t0, current_level
    li $t1, 6
    beq $t0, $t1, final_level_complete

    jal advance_level
    j update_cursor

final_level_complete:
    li $t0, 1
    sw $t0, drawing_complete
    sw $t0, level_complete
    sw $t0, game_over     
    
    li $v0, 1
    lw $a0, drawing_complete
    syscall
    lw $a0, level_complete
    syscall
    lw $a0, game_over
    syscall
    
    jal game_completed
    j update_cursor
   
submit_failed:
    li $t0, 1
    sw $t0, game_over
    j draw_game_over
    j update_cursor
    
update_cursor:
    jal paint
    j input_done

toggle_pause:
	# Toggle the pause state
	lw $t0, game_paused
	xori $t0, $t0, 1   # Flip between 0 and 1
	sw $t0, game_paused
	
	jal paint
	j input_done

restart_game:
	li $t0, 1
	sw $t0, current_level
	
	li $t0, 0
	sw $t0, score
	
	li $t0, 0
	sw $t0, game_over
	
	jal set_level_1
	
	jal paint
	j input_done

quit_game:
	li $v0, 10
	syscall

# Function to apply gravity
apply_gravity:
    addi $sp, $sp, -4
    sw $ra, 0($sp)
    
    lw $t0, game_paused
    bne $t0, $zero, gravity_done  # Skip gravity if paused
    
    jal check_platform_collision
    
    lw $t0, is_on_platform
    bne $t0, $zero, gravity_done
    
    lw $t0, char_y
    lw $t1, gravity_step
    add $t0, $t0, $t1
    
    lw $t1, screen_height
    lw $t2, character_height
    sub $t1, $t1, $t2  # Maximum allowed y position
    
    # If y > max_y, player fell off screen - game over
    ble $t0, $t1, store_y_position
    
    li $t0, 1
    sw $t0, game_over
    jal paint
    j gravity_done
    
store_y_position:
    sw $t0, char_y
    
    # Update the display
    jal paint
    
gravity_done:
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra                      

check_platform_collision:
    addi $sp, $sp, -4
    sw $ra, 0($sp)
    
    # Default: not on platform
    li $t0, 0
    sw $t0, is_on_platform
    
    lw $t9, current_level
    
    li $t8, 1
    beq $t9, $t8, check_level1_platforms
    
    li $t8, 3
    beq $t9, $t8, check_level3_platforms
    
    li $t8, 5
    beq $t9, $t8, check_level5_platforms
    
    j platforms_checked
    
check_level1_platforms:
    # Check collision with platforms 1 and 2
    li $a0, 1  # Level 1
    jal check_platforms_for_level
    j collision_check_done
    
check_level3_platforms:
    # Check collision with platforms 3 and 4 and 5
    li $a0, 3  # Level 3
    jal check_platforms_for_level
    j collision_check_done
    
check_level5_platforms:
    # Check collision with platforms 6 and 7 and 8 and 9
    li $a0, 5  # Level 5
    jal check_platforms_for_level
    
collision_check_done:
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra
    
check_platforms_for_level:
    # $a0 = level number
    addi $sp, $sp, -4
    sw $ra, 0($sp)
    
    # Get character position and dimensions
    lw $t0, char_x
    lw $t1, char_y
    lw $t2, character_width
    lw $t3, character_height
    add $t4, $t0, $t2  # character right edge
    add $t5, $t1, $t3  # character bottom edge
    
    li $t9, 1
    beq $a0, $t9, load_level1_platforms
    
    li $t9, 3
    beq $a0, $t9, load_level3_platforms
    
    li $t9, 5
    beq $a0, $t9, load_level5_platforms
    
    j platforms_checked  # Default case
    
load_level1_platforms:
    # Check platform 1
    lw $t6, platform1_x
    lw $t7, platform1_y
    lw $t8, platform1_width
    jal check_single_platform
    
    # If already on a platform, we're done
    lw $t9, is_on_platform
    bne $t9, $zero, platforms_checked
    
    # Check platform 2
    lw $t6, platform2_x
    lw $t7, platform2_y
    lw $t8, platform2_width
    jal check_single_platform
    
    j platforms_checked
    
load_level3_platforms:
    # Check platform 3
    lw $t6, platform3_x
    lw $t7, platform3_y
    lw $t8, platform3_width
    jal check_single_platform
    
    # If already on a platform, we're done
    lw $t9, is_on_platform
    bne $t9, $zero, platforms_checked
    
    # Check platform 4
    lw $t6, platform4_x
    lw $t7, platform4_y
    lw $t8, platform4_width
    jal check_single_platform
    
    # Check platform 5
    lw $t9, is_on_platform
    bne $t9, $zero, platforms_checked
    
    lw $t6, platform5_x
    lw $t7, platform5_y
    lw $t8, platform5_width
    jal check_single_platform
    
    j platforms_checked
    
load_level5_platforms:
    # Check platform 6
    lw $t6, platform6_x
    lw $t7, platform6_y
    lw $t8, platform6_width
    jal check_single_platform
    
    # If already on a platform, we're done
    lw $t9, is_on_platform
    bne $t9, $zero, platforms_checked
    
    # Check platform 7
    lw $t6, platform7_x
    lw $t7, platform7_y
    lw $t8, platform7_width
    jal check_single_platform
    
    # Check platform 8
    lw $t9, is_on_platform
    bne $t9, $zero, platforms_checked
    
    lw $t6, platform8_x
    lw $t7, platform8_y
    lw $t8, platform8_width
    jal check_single_platform
    
    # Check platform 9
    lw $t9, is_on_platform
    bne $t9, $zero, platforms_checked
    
    lw $t6, platform9_x
    lw $t7, platform9_y
    lw $t8, platform9_width
    jal check_single_platform
    
platforms_checked:
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra
    
check_single_platform:
    # $t0 = char_x, $t1 = char_y, $t4 = char_right, $t5 = char_bottom
    # $t6 = platform_x, $t7 = platform_y, $t8 = platform_width
    
    # Check if character is horizontally aligned with platform
    add $s7, $t6, $t8 
    bgt $t0, $s7, platform_check_done
    blt $t4, $t6, platform_check_done
    
    # Check if character's bottom is at or slightly below platform top
    add $s7, $t7, 1
    blt $t5, $t7, platform_check_done
    add $s7, $t7, 3
    bgt $t1, $s7, platform_check_done
    
    # Character is on this platform
    li $t0, 1
    sw $t0, is_on_platform
    
    lw $t0, character_height
    sub $t0, $t7, $t0  # Autojump!
    sw $t0, char_y
    
platform_check_done:
    jr $ra

move_right:
    # Increase x coordinate
    lw $a0, char_x
    lw $a1, move_step
    add $a0, $a0, $a1
    
    # Check boundaries
    li $a2, 125
    bgt $a0, $a2, update_complete
    
    # Update position
    sw $a0, char_x
    
    jal check_platform_collision
    
    j update_complete

move_left:
    # Decrease x coordinate
    lw $a0, char_x
    lw $a1, move_step
    sub $a0, $a0, $a1
    
    # Check boundaries
    blt $a0, $zero, update_complete
    
    sw $a0, char_x
    
    # Check if still on platform after moving
    jal check_platform_collision
    
    j update_complete

move_up:
	# Decrease y coordinate
	lw $a0, char_y
	lw $a1, move_step
	sub $a0, $a0, $a1
	
	# Check boundaries
	blt $a0, $zero, update_complete
	
	# Update position
	sw $a0, char_y
	j update_complete
	
move_down:
	lw $a0, char_y
	lw $a1, move_step
	add $a0, $a0, $a1
	
	# Check boundaries
	li $a2, 60
	bgt $a0, $a2, update_complete
	
	sw $a0, char_y
	j update_complete
	
update_complete:
	# Redraw the entire screen with updated character position -  OPTIMIZATION PROBLEM
	jal paint
	j input_done
	
no_input:
	
input_done:
	lw $ra, 0($sp)
	addi $sp, $sp, 4
	jr $ra
	
calculate_drawing_accuracy:
    la $t0, target_drawing
    la $t1, player_drawing
    li $t2, 0
    li $t3, 0 
    li $t4, 25  # Total pixels
    
accuracy_loop:
    lw $t5, 0($t0)  # Target color
    lw $t6, 0($t1)  # Player color
    
    bne $t5, $t6, skip_increment
    addi $t2, $t2, 1  # Increment match counter
    
skip_increment: 
    addi $t0, $t0, 4
    addi $t1, $t1, 4
    addi $t3, $t3, 1
    blt $t3, $t4, accuracy_loop
    
    mul $t2, $t2, 100
    div $t2, $t4
    mflo $t2
    
    sw $t2, drawing_accuracy
    
    # Update player score based on accuracy
    lw $t7, score
    add $t7, $t7, $t2
    sw $t7, score
    
    jr $ra

paint:
    addi $sp, $sp, -4
    sw $ra, 0($sp)
    
    # Clear the screen with background color
    li $t0, BASE_ADDRESS
    lw $t2, 0($s6)
    li $t5, 0 
    
background_loop:
    sw $t2, 0($t0)
    addi $t0, $t0, 4
    addi $t5, $t5, 1
    li $t6, 8192
    blt $t5, $t6, background_loop
 
    # Check if it's a drawing level
    lw $t0, current_level
    
    li $t1, 2
    beq $t0, $t1, draw_drawing_level
    li $t1, 4
    beq $t0, $t1, draw_drawing_level
    li $t1, 6
    beq $t0, $t1, draw_drawing_level
    
    # If not a drawing level, draw regular level
    jal paintgrass
    
    lw $t0, current_level   
    
    # Check if game is paused
    lw $t9, game_paused
    beq $t9, $zero, check_level_type
    jal draw_pause
    j paint_done
        
    check_level_type:
        li $t1, 1
        beq $t0, $t1, draw_level1
        
        li $t1, 3
        beq $t0, $t1, draw_level3
        
        li $t1, 5
        beq $t0, $t1, draw_level5
        
        j draw_character
    
draw_drawing_level:
    # Draw drawing game UI
    jal draw_target_drawing
    jal draw_player_drawing
    jal draw_cursor
    jal draw_color_palette
    
    jal draw_score_and_time
    
    # Then, check if drawing is complete to show accuracy
    lw $t0, drawing_complete
    beq $t0, $zero, check_drawing_paused
    jal draw_drawing_complete
    
    lw $t0, game_over
    beq $t0, $zero, check_drawing_paused
    jal draw_game_over
    j paint_done
    
check_drawing_paused:
    lw $t0, game_paused
    beq $t0, $zero, paint_done
    jal draw_pause
    j paint_done
    
draw_level1:
    # Draw platforms for level 1
    lw $a0, platform1_x
    lw $a1, platform1_y
    lw $a2, platform1_width
    lw $a3, platform1_height
    jal paint_single_platform
    
    lw $a0, platform2_x
    lw $a1, platform2_y
    lw $a2, platform2_width
    lw $a3, platform2_height
    jal paint_single_platform
    
    # Draw pickups if visible - fixing coordinates for each pickup
    lw $t0, pickup1_visible
    beq $t0, $zero, skip_pickup1
    lw $a0, pickup1_x
    lw $a1, pickup1_y
    jal drawpickup
skip_pickup1:
    
    lw $t0, pickup2_visible
    beq $t0, $zero, skip_pickup2
    lw $a0, pickup2_x
    lw $a1, pickup2_y
    jal drawpickup
skip_pickup2:
    
    lw $t0, pickup3_visible
    beq $t0, $zero, skip_pickup3
    lw $a0, pickup3_x
    lw $a1, pickup3_y
    jal drawpickup
skip_pickup3:
    j draw_character
    
draw_level3:
    # Draw platforms for level 3
    lw $a0, platform3_x
    lw $a1, platform3_y
    lw $a2, platform3_width
    lw $a3, platform3_height
    jal paint_single_platform
    
    lw $a0, platform4_x
    lw $a1, platform4_y
    lw $a2, platform4_width
    lw $a3, platform4_height
    jal paint_single_platform
    
    lw $a0, platform5_x
    lw $a1, platform5_y
    lw $a2, platform5_width
    lw $a3, platform5_height
    jal paint_single_platform
    
    # Draw pickups if visible
    lw $t0, pickup4_visible
    beq $t0, $zero, skip_pickup4
    lw $a0, pickup4_x
    lw $a1, pickup4_y
    jal drawpickup
skip_pickup4:
    
    lw $t0, pickup5_visible
    beq $t0, $zero, skip_pickup5
    lw $a0, pickup5_x
    lw $a1, pickup5_y
    jal drawpickup
skip_pickup5:
    
    lw $t0, pickup6_visible
    beq $t0, $zero, skip_pickup6
    lw $a0, pickup6_x
    lw $a1, pickup6_y
    jal drawpickup
skip_pickup6:
    j draw_character
    
draw_level5:
    # Draw platforms for level 5
    lw $a0, platform6_x
    lw $a1, platform6_y
    lw $a2, platform6_width
    lw $a3, platform6_height
    jal paint_single_platform
    
    lw $a0, platform7_x
    lw $a1, platform7_y
    lw $a2, platform7_width
    lw $a3, platform7_height
    jal paint_single_platform
    
    lw $a0, platform8_x
    lw $a1, platform8_y
    lw $a2, platform8_width
    lw $a3, platform8_height
    jal paint_single_platform
    
    lw $a0, platform9_x
    lw $a1, platform9_y
    lw $a2, platform9_width
    lw $a3, platform9_height
    jal paint_single_platform
    
    # Draw pickups if visible
    lw $t0, pickup7_visible
    beq $t0, $zero, skip_pickup7
    lw $a0, pickup7_x
    lw $a1, pickup7_y
    jal drawpickup
skip_pickup7:
    
    lw $t0, pickup8_visible
    beq $t0, $zero, skip_pickup8
    lw $a0, pickup8_x
    lw $a1, pickup8_y
    jal drawpickup
skip_pickup8:
    
    lw $t0, pickup9_visible
    beq $t0, $zero, skip_pickup9
    lw $a0, pickup9_x
    lw $a1, pickup9_y
    jal drawpickup
skip_pickup9:
	j draw_character

load_target_drawing_level2:
    la $t0, target_drawing
    
    la $t1, paintingcolors
    li $t2, 2
    li $t3, 4
    li $t4, 1

    sw $t4, 0($t0)
    sw $t4, 4($t0)
    sw $t4, 8($t0)
    sw $t4, 12($t0)
    sw $t4, 16($t0)

    sw $t4, 20($t0)
    sw $t2, 24($t0)
    sw $t4, 28($t0)
    sw $t2, 32($t0)
    sw $t4, 36($t0)

    sw $t4, 40($t0)
    sw $t4, 44($t0)
    sw $t4, 48($t0)
    sw $t4, 52($t0)
    sw $t4, 56($t0)

    sw $t4, 60($t0)
    sw $t3, 64($t0)
    sw $t4, 68($t0)
    sw $t3, 72($t0)
    sw $t4, 76($t0)

    sw $t4, 80($t0)
    sw $t3, 84($t0)
    sw $t3, 88($t0)
    sw $t3, 92($t0)
    sw $t4, 96($t0)
    
    jr $ra

load_target_drawing_level4:
    la $t0, target_drawing
    
    li $t1, 0
    li $t2, 3
    li $t3, 4
    li $t4, 2
    
    # Row 1
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t3, 8($t0)
    sw $t1, 12($t0)
    sw $t1, 16($t0)
    
    # Row 2
    sw $t1, 20($t0)
    sw $t3, 24($t0)
    sw $t3, 28($t0)
    sw $t3, 32($t0)
    sw $t1, 36($t0)
    
    # Row 3
    sw $t2, 40($t0)
    sw $t2, 44($t0)
    sw $t3, 48($t0)
    sw $t4, 52($t0)
    sw $t4, 56($t0)
    
    # Row 4
    sw $t1, 60($t0)
    sw $t2, 64($t0)
    sw $t2, 68($t0)
    sw $t4, 72($t0)
    sw $t4, 76($t0)
    
    # Row 5
    sw $t4, 80($t0)
    sw $t2, 84($t0)
    sw $t2, 88($t0)
    sw $t4, 92($t0)
    sw $t4, 96($t0)
    
    jr $ra

load_target_drawing_level6:
    la $t0, target_drawing
    
    # Row 1
    li $t1, 2 
    sw $t1, 0($t0)
    li $t1, 1
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    li $t1, 2
    sw $t1, 12($t0)
    sw $t1, 16($t0)
    
    # Row 2
    li $t1, 2
    sw $t1, 20($t0)
    li $t1, 1
    sw $t1, 24($t0)
    sw $t1, 28($t0)
    li $t1, 2
    sw $t1, 32($t0)
    sw $t1, 36($t0)
    
    # Row 3
    li $t1, 2 
    sw $t1, 40($t0)
    sw $t1, 44($t0)
    sw $t1, 48($t0)
    li $t1, 3
    sw $t1, 52($t0)
    li $t1, 2
    sw $t1, 56($t0)
    
    # Row 4
    li $t1, 2
    sw $t1, 60($t0)
    li $t1, 3
    sw $t1, 64($t0)
    sw $t1, 68($t0)
    sw $t1, 72($t0)
    sw $t1, 76($t0)
    
    # Row 5
    li $t1, 3
    sw $t1, 80($t0)
    sw $t1, 84($t0)
    sw $t1, 88($t0)
    sw $t1, 92($t0)
    sw $t1, 96($t0)
    
    jr $ra
    
draw_color_palette:
    # Draw color selection boxes at bottom of screen
    li $t0, BASE_ADDRESS
    addi $t0, $t0, 30728  # Move to y=60 x = 2
    
    la $t2, paintingcolors
    
    lw $t1, 0($t2)   # 0xf7a90f (yellow)
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    
    lw $t1, 4($t2)   # 0x0017ff (blue)
    sw $t1, 16($t0)
    sw $t1, 20($t0)
    sw $t1, 24($t0)
    
    lw $t1, 8($t2)   # 0x00791a (green)
    sw $t1, 32($t0)
    sw $t1, 36($t0)
    sw $t1, 40($t0)
    
    lw $t1, 12($t2)   # 0xff0000 (red)
    sw $t1, 48($t0)
    sw $t1, 52($t0)
    sw $t1, 56($t0)
    
    # Highlight selected color
    lw $t2, current_color
    sll $t2, $t2, 4  #spacing between color boxes
    add $t0, $t0, $t2
    
    # Draw highlight border around selected color
    li $t1, 0x033
    sw $t1, -4($t0)
    sw $t1, 12($t0)
    addi $t0, $t0, -512
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 1024
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    
    jr $ra
    
draw_target_drawing:
    addi $sp, $sp, -4
    sw $s6, 0($sp)
    
    li $t0, BASE_ADDRESS
    addi $t0, $t0, 10280  # Position at left side of screen (y=20, x=25)
    
    la $t1, target_drawing
    la $t9, paintingcolors
    li $t2, 0  # Row counter
    
target_drawing_row_loop:
    li $t3, 0  # Column counter
    
target_drawing_col_loop:
    # Calculate index into target_drawing array
    mul $t4, $t2, 5
    add $t4, $t4, $t3
    sll $t4, $t4, 2
    add $t5, $t1, $t4
    
    lw $t6, 0($t5)
    beqz $t6, target_empty_pixel  # If color index is 0, use background
    
    # Get actual color from paintingcolors array
    addi $t7, $t6, -1  
    sll $t7, $t7, 2
    add $t7, $t9, $t7
    lw $t6, 0($t7)
    j draw_target_pixel
    
target_empty_pixel:
    lw $t6, 0($s6)   # Background color
    
draw_target_pixel:
    sw $t6, 0($t0)
    sw $t6, 4($t0)
    sw $t6, 512($t0)
    sw $t6, 516($t0)
    
    addi $t0, $t0, 8 
    addi $t3, $t3, 1 
    blt $t3, 5, target_drawing_col_loop
    
    # Move to next row
    addi $t0, $t0, 2048
    subi $t0, $t0, 40
    
    addi $t2, $t2, 1  # Next row
    blt $t2, 5, target_drawing_row_loop
    
    # Restore original $s6 value
    lw $s6, 0($sp)
    addi $sp, $sp, 4
    
    jr $ra

draw_player_drawing:
    li $t0, BASE_ADDRESS
    addi $t0, $t0, 10240  # Position at right side of screen (y=20, x=80)
    addi $t0, $t0, 240
    
    la $t1, player_drawing
    la $t9, paintingcolors
    li $t2, 0  # Row counter
    
player_drawing_row_loop:
    li $t3, 0  # Column counter
    
player_drawing_col_loop:
    mul $t4, $t2, 5
    add $t4, $t4, $t3
    sll $t4, $t4, 2
    add $t5, $t1, $t4
    
    # Get color index from player drawing
    lw $t6, 0($t5)
    beqz $t6, player_empty_pixel
    
    addi $t6, $t6, -1
    sll $t7, $t6, 2 
    add $t7, $t9, $t7 
    lw $t6, 0($t7)
    j draw_player_pixel
    
player_empty_pixel:
    lw $t6, 0($s6)   # Background color
    
draw_player_pixel:
    sw $t6, 0($t0)
    sw $t6, 4($t0)
    sw $t6, 512($t0)
    sw $t6, 516($t0)
    
    addi $t0, $t0, 8
    addi $t3, $t3, 1
    blt $t3, 5, player_drawing_col_loop
    
    # Move to next row
    addi $t0, $t0, 2048
    subi $t0, $t0, 40
    
    addi $t2, $t2, 1  # Next row
    blt $t2, 5, player_drawing_row_loop
    
    jr $ra

draw_cursor:
    # Draw cursor at current position on player's drawing
    li $t0, BASE_ADDRESS
    addi $t0, $t0, 10240 
    addi $t0, $t0, 240    # Move to x=80
    
    lw $t1, cursor_x
    lw $t2, cursor_y
    
    # Convert grid position to pixel position
    sll $t1, $t1, 3
    add $t0, $t0, $t1
    
    li $t3, 2048
    mul $t3, $t3, $t2
    add $t0, $t0, $t3
    
    li $t4, 0xFFFFFFF  # color for cursor
    
    # Draw top border
    sw $t4, -4($t0)
    sw $t4, 0($t0)
    sw $t4, 4($t0)
    sw $t4, 8($t0)
    sw $t4, 12($t0)
    
    # Draw left and right borders
    sw $t4, 508($t0)
    sw $t4, 1020($t0)
    sw $t4, 1532($t0)
    sw $t4, 2044($t0)
    
    sw $t4, 524($t0)
    sw $t4, 1036($t0)
    sw $t4, 1548($t0)
    sw $t4, 2060($t0)
    
    # Draw bottom border
    sw $t4, 2556($t0)
    sw $t4, 2560($t0)
    sw $t4, 2564($t0)
    sw $t4, 2568($t0)
    sw $t4, 2572($t0)
    
    jr $ra

draw_drawing_complete:
    li $t0, BASE_ADDRESS
    addi $t0, $t0, 20480  # y=40, near bottom of screen
    
    lw $t1, drawing_accuracy
    
    # Draw accuracy percentage
    li $a0, 64        
    li $a1, 40        # y position
    li $a2, 10       
    la $a3, drawing_accuracy
    jal draw_number
    
    li $t0, BASE_ADDRESS
    addi $t0, $t0, 20480  # y=40, near bottom of screen
    
    # Draw % symbol
    addi $t0, $t0, 300 
    li $t1, 0xff0000
    
    sw $t1, 0($t0)
    sw $t1, 8($t0)
    sw $t1, 520($t0)
    sw $t1, 1028($t0)
    sw $t1, 1536($t0)
    
    jr $ra
    
draw_character:
    la $s6, colors
    
    # Draw the character
    lw $a0, char_x
    lw $a1, char_y
    jal drawcharacter
    
    jal draw_score_and_time
    
    # Check if game is over or level complete
    lw $t0, game_over
    beq $t0, $zero, check_level_complete_a
    
    jal draw_game_over
    j paint_done
    
check_level_complete_a:
    lw $t0, level_complete
    beq $t0, $zero, check_game_paused
    
    li $a0, 1000
    li $v0, 32    # Sleep syscall
    syscall
    
    # Now advance to next level
    jal advance_level
    j paint_done  

check_game_paused:
    lw $t0, game_paused
    beq $t0, $zero, paint_done
    
    jal draw_pause
    
draw_completion_screen:
    jal game_completed
    j paint_done

paint_done:
    # Restore return address and return
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra

draw_score_and_time:
    addi $sp, $sp, -4
    sw $ra, 0($sp)
    
    li $t0, BASE_ADDRESS
    addi $t0, $t0, 8
    
    # Draw score value
    li $a0, 80        
    li $a1, 5         # y position
    li $a2, 10        
    la $a3, score     
    jal draw_number
    
    # Draw "TIME:" text 
    li $a0, 120        
    li $a1, 5         # y position
    li $a2, 9         
    la $a3, time_remaining 
    jal draw_number
    
    # Draw level indicator
    li $a0, 40        
    li $a1, 5         # y position
    li $a2, 11        
    la $a3, current_level 
    jal draw_number
    
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra

# Simple function to draw a number on screen
draw_number:
    # $a0 = x position, $a1 = y position, $a2 = color index, $a3 = address of number to draw
    addi $sp, $sp, -24
    sw $ra, 0($sp)
    sw $s0, 4($sp)
    sw $s1, 8($sp)
    sw $s2, 12($sp)
    sw $s3, 16($sp)
    sw $s4, 20($sp)
    
    move $s0, $a0     # Save x position
    move $s1, $a1     # Save y position
    lw $s2, 0($s6)    
    lw $s3, 0($a3)    
    li $s4, 0        
    
    beqz $s3, print_zero
    
    # First convert the number to separate digits
    move $t0, $s3 
    li $t9, 0 
    
process_digits:
    beqz $t0, draw_digits  # If no more digits, draw them
    
    # Extract the rightmost digit
    li $t1, 10
    div $t0, $t1     
    mfhi $t2       
    mflo $t0       
    
    # Save the digit on stack
    addi $sp, $sp, -4
    sw $t2, 0($sp)
    addi $t9, $t9, 4  # Track how much we pushed
    addi $s4, $s4, 1
    
    j process_digits
    
print_zero:
    # Just push a single 0 digit
    addi $sp, $sp, -4
    li $t2, 0
    sw $t2, 0($sp)
    addi $t9, $t9, 4  # Track how much we pushed
    li $s4, 1       
    
draw_digits:
    # Calculate starting position
    move $t0, $s0
    
    li $t1, 5         # Width of each digit + 1 space
    mul $t1, $t1, $s4
    sub $t0, $t0, $t1
    
    move $t8, $s4
    
digit_loop:
    beqz $t8, drawing_done
    
    lw $t2, 0($sp)    # Get digit
    addi $sp, $sp, 4
    addi $t9, $t9, -4
    
    li $t3, BASE_ADDRESS
    li $t4, 128 #hardcoded value
    mul $t5, $s1, $t4
    add $t5, $t5, $t0
    sll $t5, $t5, 2   # (y * width + x) * 4 bytes
    add $t3, $t3, $t5 # BASE_ADDRESS + offset
    
    # Choose color based on digit
    lw $t7, 36($s6)
    
    # Top row - common to all digits except for 4
    beq $t2, 4, skip_top
    beq $t2, 1, skip_top
    sw $t7, 0($t3)
    sw $t7, 4($t3)
    sw $t7, 8($t3)
skip_top:
    
    # Middle rows
    addi $t3, $t3, 512 # Next row (128 * 4)
    beq $t2, 1, digit_one_mid
    beq $t2, 2, digit_two_mid
    beq $t2, 3, digit_three_mid
    beq $t2, 4, digit_four_mid
    beq $t2, 5, digit_five_mid
    beq $t2, 6, digit_six_mid
    beq $t2, 7, digit_seven_mid
    beq $t2, 8, digit_eight_mid
    beq $t2, 9, digit_nine_mid
    beq $t2, 0, digit_zero_mid
    
    # Default pattern - unreachavble
    sw $t7, 0($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 0($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 0($t3)
    j draw_bottom
    
digit_one_mid:
    sw $t7, 8($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 8($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 8($t3)
    j draw_bottom
    
digit_zero_mid:
    sw $t7, 0($t3)
    sw $t7, 8($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 0($t3)
    sw $t7, 8($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 0($t3)
    sw $t7, 8($t3)
    j draw_bottom
    
# Add patterns for digits 2-9
digit_two_mid:
    sw $t7, 8($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 0($t3)
    sw $t7, 4($t3)
    sw $t7, 8($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 0($t3)
    j draw_bottom

digit_three_mid:
    sw $t7, 8($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 4($t3)
    sw $t7, 8($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 8($t3)
    j draw_bottom

digit_four_mid:
    sw $t7, 0($t3)
    sw $t7, 8($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 0($t3)
    sw $t7, 4($t3)
    sw $t7, 8($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 8($t3)
    j draw_bottom

digit_five_mid:
    sw $t7, 0($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 0($t3)
    sw $t7, 4($t3)
    sw $t7, 8($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 8($t3)
    j draw_bottom

digit_six_mid:
    sw $t7, 0($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 0($t3)
    sw $t7, 4($t3)
    sw $t7, 8($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 0($t3)
    sw $t7, 8($t3)
    j draw_bottom

digit_seven_mid:
    sw $t7, 8($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 8($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 8($t3)
    j draw_bottom

digit_eight_mid:
    sw $t7, 0($t3)
    sw $t7, 8($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 0($t3)
    sw $t7, 4($t3)
    sw $t7, 8($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 0($t3)
    sw $t7, 8($t3)
    j draw_bottom

digit_nine_mid:
    sw $t7, 0($t3)
    sw $t7, 8($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 0($t3)
    sw $t7, 4($t3)
    sw $t7, 8($t3)
    addi $t3, $t3, 512 # Next row
    sw $t7, 8($t3)
    j draw_bottom
    
draw_bottom:
    # Bottom row - common to all digits except 1, 4,7
    addi $t3, $t3, 512 # Next row
    beq $t2, 1, skip_bottom
    beq $t2, 4, skip_bottom
    beq $t2, 7, skip_bottom
    sw $t7, 0($t3)
    sw $t7, 4($t3)
    sw $t7, 8($t3)
skip_bottom:
    
    # Move to next digit position
    addi $t0, $t0, 5
    addi $t8, $t8, -1
    j digit_loop
    
drawing_done:

    # Restore registers and return
    lw $ra, 0($sp)
    lw $s0, 4($sp)
    lw $s1, 8($sp)
    lw $s2, 12($sp)
    lw $s3, 16($sp)
    lw $s4, 20($sp)
    addi $sp, $sp, 24
    jr $ra

draw_game_over:
    # Draw "DEAD" text at center of screen
    li $t0, BASE_ADDRESS
    
    # Calculate position (center of screen)
    li $t6, 128
    mul $t6, $t6, 32  # y = 32
    add $t6, $t6, 30  # x = 60
    mul $t6, $t6, 4
    add $t0, $t0, $t6
    
    # Set color (red)
    lw $t1, 36($s6)
    
    # D
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 12($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 12($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    
    # Move to E position
    subi $t0, $t0, 1536
    addi $t0, $t0, 20
    
    # E
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    
    # Move to A position
    subi $t0, $t0, 1536
    addi $t0, $t0, 16
    
    # A
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 12($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    sw $t1, 12($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 12($t0)
    
    # Move to D position
    subi $t0, $t0, 1536
    addi $t0, $t0, 20
    
    # D
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 12($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 12($t0)
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    
    # Draw Score
    addi $t0, $t0, 1024
    subi $t0, $t0, 60
    
    # Draw score number
    li $a0, 80           
    li $a1, 45           # y position
    li $a2, 10 
    la $a3, score
    jal draw_number
    
    j exit

draw_pause:
    li $t0, BASE_ADDRESS
    
    # Calculate position
    li $t6, 128
    mul $t6, $t6, 32  # y = 32
    add $t6, $t6, 64  # x = 64
    mul $t6, $t6, 4
    add $t0, $t0, $t6
    
    lw $t1, 20($s6)
    
    # Draw PAUSE as a simple pattern
    # Top row
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    sw $t1, 12($t0)
    sw $t1, 24($t0)
    sw $t1, 28($t0)
    sw $t1, 32($t0)
    sw $t1, 36($t0)
    
    # Middle row
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    sw $t1, 12($t0)
    sw $t1, 24($t0)
    sw $t1, 28($t0)
    sw $t1, 32($t0)
    sw $t1, 36($t0)
    
    # Bottom row
    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    sw $t1, 12($t0)
    sw $t1, 24($t0)
    sw $t1, 28($t0)
    sw $t1, 32($t0)
    sw $t1, 36($t0)

    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    sw $t1, 12($t0)
    sw $t1, 24($t0)
    sw $t1, 28($t0)
    sw $t1, 32($t0)
    sw $t1, 36($t0)

    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    sw $t1, 12($t0)
    sw $t1, 24($t0)
    sw $t1, 28($t0)
    sw $t1, 32($t0)
    sw $t1, 36($t0)

    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    sw $t1, 12($t0)
    sw $t1, 24($t0)
    sw $t1, 28($t0)
    sw $t1, 32($t0)
    sw $t1, 36($t0)

    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    sw $t1, 12($t0)
    sw $t1, 24($t0)
    sw $t1, 28($t0)
    sw $t1, 32($t0)
    sw $t1, 36($t0)

    addi $t0, $t0, 512
    sw $t1, 0($t0)
    sw $t1, 4($t0)
    sw $t1, 8($t0)
    sw $t1, 12($t0)
    sw $t1, 24($t0)
    sw $t1, 28($t0)
    sw $t1, 32($t0)
    sw $t1, 36($t0)
    
    jr $ra

paintgrass:
	# Save return address
	addi $sp, $sp, -4
	sw $ra, 0($sp)
	
	li $t5, 30720
	li $t0, BASE_ADDRESS
	addi $t0, $t0, 30720
	
	lw $t4, 12($s6)

	grass1_loop:
		addi $t0, $t0, 8
		sw $t4, 0($t0)        
		addi $t0, $t0, 28      
		sw $t4, 0($t0)
		addi $t0, $t0, 8
		addi $t5, $t5, 52      # Increment counter
		blt $t5, 31232, grass1_loop  # 131744, 32256,32768
	grass2_loop:
		sw $t4, 0($t0)        
		addi $t0, $t0, 8      
		sw $t4, 0($t0)
		addi $t0, $t0, 4      
		sw $t4, 0($t0)
		addi $t0, $t0, 8
		sw $t4, 0($t0)
		addi $t0, $t0, 12
		addi $t0, $t0, 4      
		sw $t4, 0($t0)
		addi $t0, $t0, 4      
		sw $t4, 0($t0)
		addi $t0, $t0, 8
		addi $t5, $t5, 48     # Increment counter
		blt $t5, 31744, grass2_loop  # 131744, 32256,32768
	grass3_loop:
		sw $t4, 0($t0)        
		addi $t0, $t0, 4
		sw $t4, 0($t0)        
		addi $t0, $t0, 4
		sw $t4, 0($t0)        
		addi $t0, $t0, 4
		sw $t4, 0($t0)        
		addi $t0, $t0, 4
		sw $t4, 0($t0)        
		addi $t0, $t0, 4
		sw $t4, 0($t0)        
		addi $t0, $t0, 8
		sw $t4, 0($t0)
		addi $t0, $t0, 8
		sw $t4, 0($t0)
		addi $t0, $t0, 4
		sw $t4, 0($t0)        
		addi $t0, $t0, 4
		sw $t4, 0($t0)
		addi $t0, $t0, 4
		addi $t5, $t5, 48      # Increment counter
		blt $t5, 32256, grass3_loop  # 131744, 32256,32768
	grass4_loop:
		sw $t4, 0($t0)        
		addi $t0, $t0, 4    
		sw $t4, 0($t0)
		addi $t0, $t0, 4    
		sw $t4, 0($t0)
		addi $t0, $t0, 4    
		sw $t4, 0($t0)
		addi $t0, $t0, 4    
		sw $t4, 0($t0)
		addi $t0, $t0, 4    
		sw $t4, 0($t0)
		addi $t0, $t0, 4    
		sw $t4, 0($t0)
		addi $t0, $t0, 4    
		sw $t4, 0($t0)
		addi $t0, $t0, 4    
		sw $t4, 0($t0)
		addi $t0, $t0, 4    
		sw $t4, 0($t0)
		addi $t0, $t0, 4    
		sw $t4, 0($t0)
		addi $t0, $t0, 4    
		sw $t4, 0($t0)
		addi $t0, $t0, 4    
		sw $t4, 0($t0)
		addi $t5, $t5, 48      # Increment counter
		blt $t5, 32768, grass4_loop  # 131744, 32256,32768
	
	lw $ra, 0($sp)
	addi $sp, $sp, 4
	jr $ra

paint_single_platform:
    la $t1, colors #put them to t2
    
    # Save return address and registers
    addi $sp, $sp, -20
    sw $ra, 0($sp)
    sw $a0, 4($sp)
    sw $a1, 8($sp)
    sw $a2, 12($sp)
    sw $a3, 16($sp)
    
    jal get_pixel_offset
    #$v0 contains byte offset from BASE_ADDRESS
    
    move $t5, $v0
    li $t0, BASE_ADDRESS
    add $t0, $t0, $t5
    lw $t7, 12($sp)
    mul $t8, $t7, 4
    add $t8, $t5, $t8
    
    lw $t2, 4($s6)
    lw $t3, 8($s6)
    
    pl1_loop:
        sw $t2, 0($t0)        
        addi $t0, $t0, 4      
        sw $t3, 0($t0)        
        addi $t0, $t0, 4      
        sw $t3, 0($t0)        
        addi $t0, $t0, 4      
        sw $t2, 0($t0)        
        addi $t0, $t0, 4      
        sw $t3, 0($t0)        
        addi $t0, $t0, 4      
        sw $t2, 0($t0)        
        addi $t0, $t0, 4      
        sw $t2, 0($t0)
        addi $t0, $t0, 4      
        sw $t2, 0($t0)        
        addi $t5, $t5, 32      # Increment counter
        blt $t5, $t8, pl1_loop  #value based on platform width
    
    lw $a0, 4($sp)
    lw $a1, 8($sp)
    addi $a1, $a1, 1  # Move to next row
    
    jal get_pixel_offset
    
    move $t5, $v0
    li $t0, BASE_ADDRESS
    add $t0, $t0, $t5
    lw $t7, 12($sp)
    mul $t8, $t7, 4
    add $t8, $t5, $t8
    
    pl2_loop:
        sw $t3, 0($t0)        
        addi $t0, $t0, 4      
        sw $t3, 0($t0)        
        addi $t0, $t0, 4      
        sw $t2, 0($t0)        
        addi $t0, $t0, 4      
        sw $t3, 0($t0)        
        addi $t0, $t0, 4      
        sw $t2, 0($t0)        
        addi $t0, $t0, 4      
        sw $t3, 0($t0)        
        addi $t0, $t0, 4      
        sw $t2, 0($t0)
        addi $t0, $t0, 4
        sw $t3, 0($t0)        
        addi $t5, $t5, 32      # Increment counter
        blt $t5, $t8, pl2_loop

    lw $a0, 4($sp)
    lw $a1, 8($sp)
    addi $a1, $a1, 2  # Move to third row
    
    jal get_pixel_offset
    
    move $t5, $v0
    li $t0, BASE_ADDRESS
    add $t0, $t0, $t5
    lw $t7, 12($sp)
    mul $t8, $t7, 4
    add $t8, $t5, $t8
    
    pl3_loop:
        sw $t2, 0($t0)        
        addi $t0, $t0, 4      
        sw $t3, 0($t0)        
        addi $t0, $t0, 4      
        sw $t2, 0($t0)        
        addi $t0, $t0, 4      
        sw $t2, 0($t0)        
        addi $t0, $t0, 4      
        sw $t3, 0($t0)        
        addi $t0, $t0, 4      
        sw $t3, 0($t0)        
        addi $t0, $t0, 4      
        sw $t3, 0($t0)
        addi $t0, $t0, 4
        sw $t2, 0($t0)        
        addi $t5, $t5, 32      # Increment counter
        blt $t5, $t8, pl3_loop
    
    # Restore return address and return
    lw $ra, 0($sp)
    addi $sp, $sp, 20
    jr $ra
   
skip_drawing:
    # Restore return address and return
    lw $ra, 0($sp)
    addi $sp, $sp, 12
    jr $ra

drawcharacter:
	la $s6, colors #put them to t2
	addi $sp, $sp, -12
	sw $ra, 0($sp)
	sw $a0, 4($sp)
	sw $a1, 8($sp)

    #boundary check
    li $t9, 125 #hardcoded value
    bgt $a0, $t9, drawcharacter_done
    bltz $a0, drawcharacter_done  # Check if x < 0
    
    li $t9, 56 #hardcoded value
    bgt $a1, $t9, drawcharacter_done
    bltz $a1, drawcharacter_done  # Check if y < 0
	
	jal get_pixel_offset
	#$v0 contains byte offset from BASE_ADDRESS
	move $t5, $v0
	li $t0, BASE_ADDRESS
	add $t0, $t0, $t5

	lw $s0, 24($s6)
	lw $s1, 28($s6)
	lw $t6, 16($s6)
	lw $t7, 20($s6)
	
	sw $s0, 0($t0)
	addi $t0, $t0, 4
	sw $s1, 0($t0)
	addi $t0, $t0, 4
	sw $s0, 0($t0)
	
	# Move to next row
	addi $t0, $t0, 504
	sw $s1, 0($t0)
	addi $t0, $t0, 4
	sw $s0, 0($t0)
	addi $t0, $t0, 4
	sw $s1, 0($t0)
	
	# Move to next row
	addi $t0, $t0, 504
	sw $t7, 0($t0)
	addi $t0, $t0, 4
	sw $t7, 0($t0)
	addi $t0, $t0, 4
	sw $t7, 0($t0)
	
	# Move to next row
	addi $t0, $t0, 504
	sw $t6, 0($t0)
	addi $t0, $t0, 4
	sw $t6, 0($t0)
	addi $t0, $t0, 4
	sw $t6, 0($t0)
	
	# Move to next row
	addi $t0, $t0, 508
	sw $t6, 0($t0)
	
	# Move to next row
	addi $t0, $t0, 512
	sw $t6, 0($t0)
	
	# Move to next row
	addi $t0, $t0, 512
	sw $t7, 0($t0)
	
	# Restore return address and return
	lw $ra, 0($sp)
	addi $sp, $sp, 12
	jr $ra

drawcharacter_done:
    # Restore return address and return
    lw $ra, 0($sp)
    addi $sp, $sp, 12
    jr $ra

drawpickup:
	
	la $t1, colors #put them to t2
	addi $sp, $sp, -12
	sw $ra, 0($sp)
	sw $a0, 4($sp)
	sw $a1, 8($sp)
	
	
	jal get_pixel_offset
	#$v0 contains byte offset from BASE_ADDRESS
	move $t5, $v0
	li $t0, BASE_ADDRESS
	add $t0, $t0, $t5
	
	lw $s2, 32($s6)
	lw $s3, 36($s6)
	lw $s4, 40($s6)
	lw $s5, 44($s6)
	lw $s0, 24($s6)
	lw $s1, 28($s6)
	lw $t7, 20($s6)


	addi $t0, $t0, 12
	sw $s2, 0($t0)
	addi $t0, $t0, 4
	sw $s2, 0($t0)
	addi $t0, $t0, 4
	sw $s2, 0($t0)
	
	# Next row
	addi $t0, $t0, 500
	sw $s2, 0($t0)
	addi $t0, $t0, 4
	sw $s3, 0($t0)
	addi $t0, $t0, 4
	sw $s3, 0($t0)
	addi $t0, $t0, 4
	sw $s0, 0($t0)
	addi $t0, $t0, 4
	sw $s2, 0($t0)
	addi $t0, $t0, 4
	
	# Next row
	addi $t0, $t0, 488
	sw $s2, 0($t0)
	addi $t0, $t0, 4
	sw $s4, 0($t0) 
	addi $t0, $t0, 4
	sw $s2, 0($t0)
	addi $t0, $t0, 4
	sw $s3, 0($t0)
	addi $t0, $t0, 4
	sw $s2, 0($t0)
	addi $t0, $t0, 4
	sw $s0, 0($t0)
	addi $t0, $t0, 4
	sw $s2, 0($t0)
	
	# Next row
	addi $t0, $t0, 488
	sw $s2, 0($t0)
	addi $t0, $t0, 4
	sw $s4, 0($t0) 
	addi $t0, $t0, 4
	sw $s2, 0($t0)
	addi $t0, $t0, 12
	sw $t7, 0($t0)
	addi $t0, $t0, 4
	sw $s2, 0($t0)
	
	# Next row
	addi $t0, $t0, 488
	sw $s2, 0($t0)
	addi $t0, $t0, 4
	sw $s5, 0($t0) 
	addi $t0, $t0, 4
	sw $s5, 0($t0)
	addi $t0, $t0, 4
	sw $s2, 0($t0)
	addi $t0, $t0, 4
	sw $s2, 0($t0)
	addi $t0, $t0, 4
	sw $s2, 0($t0)
	addi $t0, $t0, 4
	sw $s2, 0($t0)
	
	# Next row
	addi $t0, $t0, 492
	sw $s2, 0($t0)
	addi $t0, $t0, 4
	sw $s5, 0($t0)
	addi $t0, $t0, 4
	sw $s1, 0($t0)
	addi $t0, $t0, 4
	sw $s2, 0($t0)
	
	# Next row
	addi $t0, $t0, 504
	sw $s2, 0($t0)
	addi $t0, $t0, 4
	sw $s2, 0($t0)
	addi $t0, $t0, 4
	sw $s2, 0($t0)
	addi $t0, $t0, 4
	sw $s2, 0($t0)
	
	# Restore return address and return
	lw $ra, 0($sp)
	addi $sp, $sp, 12
	jr $ra
	
pickup_done: 
	jr $ra

#output: $v0 = offset in bytes from BASE_ADDRESS
get_pixel_offset:
    li $t0, 128
    mul $t1, $a1, $t0 
    add $t1, $t1, $a0
    sll $v0, $t1, 2      # v0 = (y * 128 + x) * 4
    jr $ra
	
exit:
	li $v0, 10
	syscall
